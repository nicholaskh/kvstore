// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: phxkv.proto
#ifndef GRPC_phxkv_2eproto__INCLUDED
#define GRPC_phxkv_2eproto__INCLUDED

#include "phxkv.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace phxkv {

class PhxKVServer final {
 public:
  static constexpr char const* service_full_name() {
    return "phxkv.PhxKVServer";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status KvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::phxkv::KVResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>> AsyncKvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>>(AsyncKvPutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>> PrepareAsyncKvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>>(PrepareAsyncKvPutRaw(context, request, cq));
    }
    virtual ::grpc::Status KvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::phxkv::KVResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>> AsyncKvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>>(AsyncKvGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>> PrepareAsyncKvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>>(PrepareAsyncKvGetRaw(context, request, cq));
    }
    virtual ::grpc::Status KvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::phxkv::KVResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>> AsyncKvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>>(AsyncKvGetLocalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>> PrepareAsyncKvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>>(PrepareAsyncKvGetLocalRaw(context, request, cq));
    }
    virtual ::grpc::Status KvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::phxkv::KVResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>> AsyncKvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>>(AsyncKvDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>> PrepareAsyncKvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>>(PrepareAsyncKvDeleteRaw(context, request, cq));
    }
    virtual ::grpc::Status KvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::phxkv::KvBatchPutResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchPutResponse>> AsyncKvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchPutResponse>>(AsyncKvBatchPutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchPutResponse>> PrepareAsyncKvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchPutResponse>>(PrepareAsyncKvBatchPutRaw(context, request, cq));
    }
    virtual ::grpc::Status KvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::phxkv::KvBatchGetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchGetResponse>> AsyncKvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchGetResponse>>(AsyncKvBatchGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchGetResponse>> PrepareAsyncKvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchGetResponse>>(PrepareAsyncKvBatchGetRaw(context, request, cq));
    }
    virtual ::grpc::Status KvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::phxkv::GroupListRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::GroupListRes>> AsyncKvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::GroupListRes>>(AsyncKvGetgroupListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::GroupListRes>> PrepareAsyncKvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::GroupListRes>>(PrepareAsyncKvGetgroupListRaw(context, request, cq));
    }
    virtual ::grpc::Status KvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::phxkv::DropMastRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::DropMastRes>> AsyncKvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::DropMastRes>>(AsyncKvDropMasterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::DropMastRes>> PrepareAsyncKvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::DropMastRes>>(PrepareAsyncKvDropMasterRaw(context, request, cq));
    }
    virtual ::grpc::Status KvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::phxkv::BemasterRes* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::BemasterRes>> AsyncKvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::BemasterRes>>(AsyncKvBeMasterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::BemasterRes>> PrepareAsyncKvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::BemasterRes>>(PrepareAsyncKvBeMasterRaw(context, request, cq));
    }
    // 以下为hash接口
    //
    virtual ::grpc::Status HashOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::phxkv::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>> AsyncHashOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>>(AsyncHashOperateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>> PrepareAsyncHashOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>>(PrepareAsyncHashOperateRaw(context, request, cq));
    }
    virtual ::grpc::Status ListOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::phxkv::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>> AsyncListOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>>(AsyncListOperateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>> PrepareAsyncListOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>>(PrepareAsyncListOperateRaw(context, request, cq));
    }
    virtual ::grpc::Status SetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::phxkv::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>> AsyncSetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>>(AsyncSetOperateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>> PrepareAsyncSetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>>(PrepareAsyncSetOperateRaw(context, request, cq));
    }
    virtual ::grpc::Status ZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::phxkv::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>> AsyncZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>>(AsyncZsetOperateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>> PrepareAsyncZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>>(PrepareAsyncZsetOperateRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void KvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void KvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void KvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvGetLocal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvGetLocal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvGetLocal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void KvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void KvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest* request, ::phxkv::KvBatchPutResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvBatchPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchPutResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest* request, ::phxkv::KvBatchPutResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest* request, ::phxkv::KvBatchPutResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvBatchPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchPutResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvBatchPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchPutResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void KvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest* request, ::phxkv::KvBatchGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvBatchGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchGetResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest* request, ::phxkv::KvBatchGetResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest* request, ::phxkv::KvBatchGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvBatchGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchGetResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvBatchGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void KvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq* request, ::phxkv::GroupListRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvGetgroupList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::GroupListRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq* request, ::phxkv::GroupListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq* request, ::phxkv::GroupListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvGetgroupList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::GroupListRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvGetgroupList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::GroupListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void KvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq* request, ::phxkv::DropMastRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvDropMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::DropMastRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq* request, ::phxkv::DropMastRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq* request, ::phxkv::DropMastRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvDropMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::DropMastRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvDropMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::DropMastRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void KvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq* request, ::phxkv::BemasterRes* response, std::function<void(::grpc::Status)>) = 0;
      virtual void KvBeMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::BemasterRes* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq* request, ::phxkv::BemasterRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq* request, ::phxkv::BemasterRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KvBeMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::BemasterRes* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KvBeMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::BemasterRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // 以下为hash接口
      //
      virtual void HashOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HashOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void HashOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void HashOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void HashOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void HashOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ListOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ZsetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ZsetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ZsetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>* AsyncKvPutRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>* PrepareAsyncKvPutRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>* AsyncKvGetRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>* PrepareAsyncKvGetRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>* AsyncKvGetLocalRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>* PrepareAsyncKvGetLocalRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>* AsyncKvDeleteRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KVResponse>* PrepareAsyncKvDeleteRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchPutResponse>* AsyncKvBatchPutRaw(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchPutResponse>* PrepareAsyncKvBatchPutRaw(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchGetResponse>* AsyncKvBatchGetRaw(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::KvBatchGetResponse>* PrepareAsyncKvBatchGetRaw(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::GroupListRes>* AsyncKvGetgroupListRaw(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::GroupListRes>* PrepareAsyncKvGetgroupListRaw(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::DropMastRes>* AsyncKvDropMasterRaw(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::DropMastRes>* PrepareAsyncKvDropMasterRaw(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::BemasterRes>* AsyncKvBeMasterRaw(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::BemasterRes>* PrepareAsyncKvBeMasterRaw(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>* AsyncHashOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>* PrepareAsyncHashOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>* AsyncListOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>* PrepareAsyncListOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>* AsyncSetOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>* PrepareAsyncSetOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>* AsyncZsetOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::phxkv::Response>* PrepareAsyncZsetOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status KvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::phxkv::KVResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>> AsyncKvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>>(AsyncKvPutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>> PrepareAsyncKvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>>(PrepareAsyncKvPutRaw(context, request, cq));
    }
    ::grpc::Status KvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::phxkv::KVResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>> AsyncKvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>>(AsyncKvGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>> PrepareAsyncKvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>>(PrepareAsyncKvGetRaw(context, request, cq));
    }
    ::grpc::Status KvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::phxkv::KVResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>> AsyncKvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>>(AsyncKvGetLocalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>> PrepareAsyncKvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>>(PrepareAsyncKvGetLocalRaw(context, request, cq));
    }
    ::grpc::Status KvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::phxkv::KVResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>> AsyncKvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>>(AsyncKvDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>> PrepareAsyncKvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>>(PrepareAsyncKvDeleteRaw(context, request, cq));
    }
    ::grpc::Status KvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::phxkv::KvBatchPutResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchPutResponse>> AsyncKvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchPutResponse>>(AsyncKvBatchPutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchPutResponse>> PrepareAsyncKvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchPutResponse>>(PrepareAsyncKvBatchPutRaw(context, request, cq));
    }
    ::grpc::Status KvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::phxkv::KvBatchGetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchGetResponse>> AsyncKvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchGetResponse>>(AsyncKvBatchGetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchGetResponse>> PrepareAsyncKvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchGetResponse>>(PrepareAsyncKvBatchGetRaw(context, request, cq));
    }
    ::grpc::Status KvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::phxkv::GroupListRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::GroupListRes>> AsyncKvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::GroupListRes>>(AsyncKvGetgroupListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::GroupListRes>> PrepareAsyncKvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::GroupListRes>>(PrepareAsyncKvGetgroupListRaw(context, request, cq));
    }
    ::grpc::Status KvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::phxkv::DropMastRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::DropMastRes>> AsyncKvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::DropMastRes>>(AsyncKvDropMasterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::DropMastRes>> PrepareAsyncKvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::DropMastRes>>(PrepareAsyncKvDropMasterRaw(context, request, cq));
    }
    ::grpc::Status KvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::phxkv::BemasterRes* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::BemasterRes>> AsyncKvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::BemasterRes>>(AsyncKvBeMasterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::BemasterRes>> PrepareAsyncKvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::BemasterRes>>(PrepareAsyncKvBeMasterRaw(context, request, cq));
    }
    ::grpc::Status HashOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::phxkv::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>> AsyncHashOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>>(AsyncHashOperateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>> PrepareAsyncHashOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>>(PrepareAsyncHashOperateRaw(context, request, cq));
    }
    ::grpc::Status ListOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::phxkv::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>> AsyncListOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>>(AsyncListOperateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>> PrepareAsyncListOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>>(PrepareAsyncListOperateRaw(context, request, cq));
    }
    ::grpc::Status SetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::phxkv::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>> AsyncSetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>>(AsyncSetOperateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>> PrepareAsyncSetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>>(PrepareAsyncSetOperateRaw(context, request, cq));
    }
    ::grpc::Status ZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::phxkv::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>> AsyncZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>>(AsyncZsetOperateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>> PrepareAsyncZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::phxkv::Response>>(PrepareAsyncZsetOperateRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void KvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) override;
      void KvPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvPut(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) override;
      void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvGet(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) override;
      void KvGetLocal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvGetLocal(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvGetLocal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvGetLocal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) override;
      void KvDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvDelete(::grpc::ClientContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvDelete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KVResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest* request, ::phxkv::KvBatchPutResponse* response, std::function<void(::grpc::Status)>) override;
      void KvBatchPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchPutResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest* request, ::phxkv::KvBatchPutResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvBatchPut(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest* request, ::phxkv::KvBatchPutResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvBatchPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchPutResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvBatchPut(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchPutResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest* request, ::phxkv::KvBatchGetResponse* response, std::function<void(::grpc::Status)>) override;
      void KvBatchGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchGetResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest* request, ::phxkv::KvBatchGetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvBatchGet(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest* request, ::phxkv::KvBatchGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvBatchGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchGetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvBatchGet(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::KvBatchGetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq* request, ::phxkv::GroupListRes* response, std::function<void(::grpc::Status)>) override;
      void KvGetgroupList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::GroupListRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq* request, ::phxkv::GroupListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvGetgroupList(::grpc::ClientContext* context, const ::phxkv::GroupListReq* request, ::phxkv::GroupListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvGetgroupList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::GroupListRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvGetgroupList(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::GroupListRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq* request, ::phxkv::DropMastRes* response, std::function<void(::grpc::Status)>) override;
      void KvDropMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::DropMastRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq* request, ::phxkv::DropMastRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvDropMaster(::grpc::ClientContext* context, const ::phxkv::DropMastReq* request, ::phxkv::DropMastRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvDropMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::DropMastRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvDropMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::DropMastRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq* request, ::phxkv::BemasterRes* response, std::function<void(::grpc::Status)>) override;
      void KvBeMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::BemasterRes* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq* request, ::phxkv::BemasterRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvBeMaster(::grpc::ClientContext* context, const ::phxkv::BemasterReq* request, ::phxkv::BemasterRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KvBeMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::BemasterRes* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KvBeMaster(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::BemasterRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void HashOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) override;
      void HashOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void HashOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void HashOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void HashOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void HashOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) override;
      void ListOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) override;
      void SetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) override;
      void ZsetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ZsetOperate(::grpc::ClientContext* context, const ::phxkv::Request* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ZsetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ZsetOperate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::phxkv::Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>* AsyncKvPutRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>* PrepareAsyncKvPutRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>* AsyncKvGetRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>* PrepareAsyncKvGetRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>* AsyncKvGetLocalRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>* PrepareAsyncKvGetLocalRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>* AsyncKvDeleteRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KVResponse>* PrepareAsyncKvDeleteRaw(::grpc::ClientContext* context, const ::phxkv::KVOperator& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchPutResponse>* AsyncKvBatchPutRaw(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchPutResponse>* PrepareAsyncKvBatchPutRaw(::grpc::ClientContext* context, const ::phxkv::KvBatchPutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchGetResponse>* AsyncKvBatchGetRaw(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::KvBatchGetResponse>* PrepareAsyncKvBatchGetRaw(::grpc::ClientContext* context, const ::phxkv::KvBatchGetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::GroupListRes>* AsyncKvGetgroupListRaw(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::GroupListRes>* PrepareAsyncKvGetgroupListRaw(::grpc::ClientContext* context, const ::phxkv::GroupListReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::DropMastRes>* AsyncKvDropMasterRaw(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::DropMastRes>* PrepareAsyncKvDropMasterRaw(::grpc::ClientContext* context, const ::phxkv::DropMastReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::BemasterRes>* AsyncKvBeMasterRaw(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::BemasterRes>* PrepareAsyncKvBeMasterRaw(::grpc::ClientContext* context, const ::phxkv::BemasterReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::Response>* AsyncHashOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::Response>* PrepareAsyncHashOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::Response>* AsyncListOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::Response>* PrepareAsyncListOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::Response>* AsyncSetOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::Response>* PrepareAsyncSetOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::Response>* AsyncZsetOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::phxkv::Response>* PrepareAsyncZsetOperateRaw(::grpc::ClientContext* context, const ::phxkv::Request& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_KvPut_;
    const ::grpc::internal::RpcMethod rpcmethod_KvGet_;
    const ::grpc::internal::RpcMethod rpcmethod_KvGetLocal_;
    const ::grpc::internal::RpcMethod rpcmethod_KvDelete_;
    const ::grpc::internal::RpcMethod rpcmethod_KvBatchPut_;
    const ::grpc::internal::RpcMethod rpcmethod_KvBatchGet_;
    const ::grpc::internal::RpcMethod rpcmethod_KvGetgroupList_;
    const ::grpc::internal::RpcMethod rpcmethod_KvDropMaster_;
    const ::grpc::internal::RpcMethod rpcmethod_KvBeMaster_;
    const ::grpc::internal::RpcMethod rpcmethod_HashOperate_;
    const ::grpc::internal::RpcMethod rpcmethod_ListOperate_;
    const ::grpc::internal::RpcMethod rpcmethod_SetOperate_;
    const ::grpc::internal::RpcMethod rpcmethod_ZsetOperate_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status KvPut(::grpc::ServerContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response);
    virtual ::grpc::Status KvGet(::grpc::ServerContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response);
    virtual ::grpc::Status KvGetLocal(::grpc::ServerContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response);
    virtual ::grpc::Status KvDelete(::grpc::ServerContext* context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response);
    virtual ::grpc::Status KvBatchPut(::grpc::ServerContext* context, const ::phxkv::KvBatchPutRequest* request, ::phxkv::KvBatchPutResponse* response);
    virtual ::grpc::Status KvBatchGet(::grpc::ServerContext* context, const ::phxkv::KvBatchGetRequest* request, ::phxkv::KvBatchGetResponse* response);
    virtual ::grpc::Status KvGetgroupList(::grpc::ServerContext* context, const ::phxkv::GroupListReq* request, ::phxkv::GroupListRes* response);
    virtual ::grpc::Status KvDropMaster(::grpc::ServerContext* context, const ::phxkv::DropMastReq* request, ::phxkv::DropMastRes* response);
    virtual ::grpc::Status KvBeMaster(::grpc::ServerContext* context, const ::phxkv::BemasterReq* request, ::phxkv::BemasterRes* response);
    // 以下为hash接口
    //
    virtual ::grpc::Status HashOperate(::grpc::ServerContext* context, const ::phxkv::Request* request, ::phxkv::Response* response);
    virtual ::grpc::Status ListOperate(::grpc::ServerContext* context, const ::phxkv::Request* request, ::phxkv::Response* response);
    virtual ::grpc::Status SetOperate(::grpc::ServerContext* context, const ::phxkv::Request* request, ::phxkv::Response* response);
    virtual ::grpc::Status ZsetOperate(::grpc::ServerContext* context, const ::phxkv::Request* request, ::phxkv::Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_KvPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvPut() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_KvPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPut(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvPut(::grpc::ServerContext* context, ::phxkv::KVOperator* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::KVResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvGet() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvGet(::grpc::ServerContext* context, ::phxkv::KVOperator* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::KVResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvGetLocal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvGetLocal() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_KvGetLocal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetLocal(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvGetLocal(::grpc::ServerContext* context, ::phxkv::KVOperator* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::KVResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvDelete() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_KvDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDelete(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvDelete(::grpc::ServerContext* context, ::phxkv::KVOperator* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::KVResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvBatchPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvBatchPut() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_KvBatchPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchPut(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchPutRequest* /*request*/, ::phxkv::KvBatchPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvBatchPut(::grpc::ServerContext* context, ::phxkv::KvBatchPutRequest* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::KvBatchPutResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvBatchGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvBatchGet() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_KvBatchGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchGet(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchGetRequest* /*request*/, ::phxkv::KvBatchGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvBatchGet(::grpc::ServerContext* context, ::phxkv::KvBatchGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::KvBatchGetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvGetgroupList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvGetgroupList() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_KvGetgroupList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetgroupList(::grpc::ServerContext* /*context*/, const ::phxkv::GroupListReq* /*request*/, ::phxkv::GroupListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvGetgroupList(::grpc::ServerContext* context, ::phxkv::GroupListReq* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::GroupListRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvDropMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvDropMaster() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_KvDropMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDropMaster(::grpc::ServerContext* /*context*/, const ::phxkv::DropMastReq* /*request*/, ::phxkv::DropMastRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvDropMaster(::grpc::ServerContext* context, ::phxkv::DropMastReq* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::DropMastRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KvBeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KvBeMaster() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_KvBeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBeMaster(::grpc::ServerContext* /*context*/, const ::phxkv::BemasterReq* /*request*/, ::phxkv::BemasterRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvBeMaster(::grpc::ServerContext* context, ::phxkv::BemasterReq* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::BemasterRes>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HashOperate() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_HashOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashOperate(::grpc::ServerContext* context, ::phxkv::Request* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListOperate() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ListOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListOperate(::grpc::ServerContext* context, ::phxkv::Request* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetOperate() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_SetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetOperate(::grpc::ServerContext* context, ::phxkv::Request* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ZsetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ZsetOperate() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ZsetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZsetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestZsetOperate(::grpc::ServerContext* context, ::phxkv::Request* request, ::grpc::ServerAsyncResponseWriter< ::phxkv::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_KvPut<WithAsyncMethod_KvGet<WithAsyncMethod_KvGetLocal<WithAsyncMethod_KvDelete<WithAsyncMethod_KvBatchPut<WithAsyncMethod_KvBatchGet<WithAsyncMethod_KvGetgroupList<WithAsyncMethod_KvDropMaster<WithAsyncMethod_KvBeMaster<WithAsyncMethod_HashOperate<WithAsyncMethod_ListOperate<WithAsyncMethod_SetOperate<WithAsyncMethod_ZsetOperate<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvPut() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KVOperator, ::phxkv::KVResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response) { return this->KvPut(context, request, response); }));}
    void SetMessageAllocatorFor_KvPut(
        ::grpc::experimental::MessageAllocator< ::phxkv::KVOperator, ::phxkv::KVResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KVOperator, ::phxkv::KVResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPut(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvPut(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvPut(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvGet() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KVOperator, ::phxkv::KVResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response) { return this->KvGet(context, request, response); }));}
    void SetMessageAllocatorFor_KvGet(
        ::grpc::experimental::MessageAllocator< ::phxkv::KVOperator, ::phxkv::KVResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KVOperator, ::phxkv::KVResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvGet(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvGet(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvGetLocal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvGetLocal() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KVOperator, ::phxkv::KVResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response) { return this->KvGetLocal(context, request, response); }));}
    void SetMessageAllocatorFor_KvGetLocal(
        ::grpc::experimental::MessageAllocator< ::phxkv::KVOperator, ::phxkv::KVResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KVOperator, ::phxkv::KVResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvGetLocal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetLocal(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvGetLocal(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvGetLocal(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvDelete() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KVOperator, ::phxkv::KVResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::KVOperator* request, ::phxkv::KVResponse* response) { return this->KvDelete(context, request, response); }));}
    void SetMessageAllocatorFor_KvDelete(
        ::grpc::experimental::MessageAllocator< ::phxkv::KVOperator, ::phxkv::KVResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KVOperator, ::phxkv::KVResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDelete(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvDelete(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvDelete(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvBatchPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvBatchPut() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KvBatchPutRequest, ::phxkv::KvBatchPutResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::KvBatchPutRequest* request, ::phxkv::KvBatchPutResponse* response) { return this->KvBatchPut(context, request, response); }));}
    void SetMessageAllocatorFor_KvBatchPut(
        ::grpc::experimental::MessageAllocator< ::phxkv::KvBatchPutRequest, ::phxkv::KvBatchPutResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KvBatchPutRequest, ::phxkv::KvBatchPutResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvBatchPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchPut(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchPutRequest* /*request*/, ::phxkv::KvBatchPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvBatchPut(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::KvBatchPutRequest* /*request*/, ::phxkv::KvBatchPutResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvBatchPut(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::KvBatchPutRequest* /*request*/, ::phxkv::KvBatchPutResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvBatchGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvBatchGet() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KvBatchGetRequest, ::phxkv::KvBatchGetResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::KvBatchGetRequest* request, ::phxkv::KvBatchGetResponse* response) { return this->KvBatchGet(context, request, response); }));}
    void SetMessageAllocatorFor_KvBatchGet(
        ::grpc::experimental::MessageAllocator< ::phxkv::KvBatchGetRequest, ::phxkv::KvBatchGetResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::KvBatchGetRequest, ::phxkv::KvBatchGetResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvBatchGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchGet(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchGetRequest* /*request*/, ::phxkv::KvBatchGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvBatchGet(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::KvBatchGetRequest* /*request*/, ::phxkv::KvBatchGetResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvBatchGet(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::KvBatchGetRequest* /*request*/, ::phxkv::KvBatchGetResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvGetgroupList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvGetgroupList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::GroupListReq, ::phxkv::GroupListRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::GroupListReq* request, ::phxkv::GroupListRes* response) { return this->KvGetgroupList(context, request, response); }));}
    void SetMessageAllocatorFor_KvGetgroupList(
        ::grpc::experimental::MessageAllocator< ::phxkv::GroupListReq, ::phxkv::GroupListRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::GroupListReq, ::phxkv::GroupListRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvGetgroupList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetgroupList(::grpc::ServerContext* /*context*/, const ::phxkv::GroupListReq* /*request*/, ::phxkv::GroupListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvGetgroupList(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::GroupListReq* /*request*/, ::phxkv::GroupListRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvGetgroupList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::GroupListReq* /*request*/, ::phxkv::GroupListRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvDropMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvDropMaster() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::DropMastReq, ::phxkv::DropMastRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::DropMastReq* request, ::phxkv::DropMastRes* response) { return this->KvDropMaster(context, request, response); }));}
    void SetMessageAllocatorFor_KvDropMaster(
        ::grpc::experimental::MessageAllocator< ::phxkv::DropMastReq, ::phxkv::DropMastRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::DropMastReq, ::phxkv::DropMastRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvDropMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDropMaster(::grpc::ServerContext* /*context*/, const ::phxkv::DropMastReq* /*request*/, ::phxkv::DropMastRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvDropMaster(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::DropMastReq* /*request*/, ::phxkv::DropMastRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvDropMaster(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::DropMastReq* /*request*/, ::phxkv::DropMastRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KvBeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KvBeMaster() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::BemasterReq, ::phxkv::BemasterRes>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::BemasterReq* request, ::phxkv::BemasterRes* response) { return this->KvBeMaster(context, request, response); }));}
    void SetMessageAllocatorFor_KvBeMaster(
        ::grpc::experimental::MessageAllocator< ::phxkv::BemasterReq, ::phxkv::BemasterRes>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::BemasterReq, ::phxkv::BemasterRes>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KvBeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBeMaster(::grpc::ServerContext* /*context*/, const ::phxkv::BemasterReq* /*request*/, ::phxkv::BemasterRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvBeMaster(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::BemasterReq* /*request*/, ::phxkv::BemasterRes* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvBeMaster(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::BemasterReq* /*request*/, ::phxkv::BemasterRes* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HashOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_HashOperate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::Request, ::phxkv::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::Request* request, ::phxkv::Response* response) { return this->HashOperate(context, request, response); }));}
    void SetMessageAllocatorFor_HashOperate(
        ::grpc::experimental::MessageAllocator< ::phxkv::Request, ::phxkv::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::Request, ::phxkv::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_HashOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HashOperate(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HashOperate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListOperate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::Request, ::phxkv::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::Request* request, ::phxkv::Response* response) { return this->ListOperate(context, request, response); }));}
    void SetMessageAllocatorFor_ListOperate(
        ::grpc::experimental::MessageAllocator< ::phxkv::Request, ::phxkv::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::Request, ::phxkv::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListOperate(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListOperate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetOperate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::Request, ::phxkv::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::Request* request, ::phxkv::Response* response) { return this->SetOperate(context, request, response); }));}
    void SetMessageAllocatorFor_SetOperate(
        ::grpc::experimental::MessageAllocator< ::phxkv::Request, ::phxkv::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::Request, ::phxkv::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetOperate(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetOperate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ZsetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ZsetOperate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::Request, ::phxkv::Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::phxkv::Request* request, ::phxkv::Response* response) { return this->ZsetOperate(context, request, response); }));}
    void SetMessageAllocatorFor_ZsetOperate(
        ::grpc::experimental::MessageAllocator< ::phxkv::Request, ::phxkv::Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::phxkv::Request, ::phxkv::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ZsetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZsetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ZsetOperate(
      ::grpc::CallbackServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ZsetOperate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_KvPut<ExperimentalWithCallbackMethod_KvGet<ExperimentalWithCallbackMethod_KvGetLocal<ExperimentalWithCallbackMethod_KvDelete<ExperimentalWithCallbackMethod_KvBatchPut<ExperimentalWithCallbackMethod_KvBatchGet<ExperimentalWithCallbackMethod_KvGetgroupList<ExperimentalWithCallbackMethod_KvDropMaster<ExperimentalWithCallbackMethod_KvBeMaster<ExperimentalWithCallbackMethod_HashOperate<ExperimentalWithCallbackMethod_ListOperate<ExperimentalWithCallbackMethod_SetOperate<ExperimentalWithCallbackMethod_ZsetOperate<Service > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_KvPut<ExperimentalWithCallbackMethod_KvGet<ExperimentalWithCallbackMethod_KvGetLocal<ExperimentalWithCallbackMethod_KvDelete<ExperimentalWithCallbackMethod_KvBatchPut<ExperimentalWithCallbackMethod_KvBatchGet<ExperimentalWithCallbackMethod_KvGetgroupList<ExperimentalWithCallbackMethod_KvDropMaster<ExperimentalWithCallbackMethod_KvBeMaster<ExperimentalWithCallbackMethod_HashOperate<ExperimentalWithCallbackMethod_ListOperate<ExperimentalWithCallbackMethod_SetOperate<ExperimentalWithCallbackMethod_ZsetOperate<Service > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_KvPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvPut() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_KvPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPut(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvGet() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvGetLocal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvGetLocal() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_KvGetLocal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetLocal(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvDelete() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_KvDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDelete(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvBatchPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvBatchPut() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_KvBatchPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchPut(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchPutRequest* /*request*/, ::phxkv::KvBatchPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvBatchGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvBatchGet() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_KvBatchGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchGet(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchGetRequest* /*request*/, ::phxkv::KvBatchGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvGetgroupList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvGetgroupList() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_KvGetgroupList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetgroupList(::grpc::ServerContext* /*context*/, const ::phxkv::GroupListReq* /*request*/, ::phxkv::GroupListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvDropMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvDropMaster() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_KvDropMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDropMaster(::grpc::ServerContext* /*context*/, const ::phxkv::DropMastReq* /*request*/, ::phxkv::DropMastRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KvBeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KvBeMaster() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_KvBeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBeMaster(::grpc::ServerContext* /*context*/, const ::phxkv::BemasterReq* /*request*/, ::phxkv::BemasterRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HashOperate() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_HashOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListOperate() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ListOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetOperate() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_SetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ZsetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ZsetOperate() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ZsetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZsetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvPut() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_KvPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPut(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvPut(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvGet() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvGetLocal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvGetLocal() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_KvGetLocal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetLocal(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvGetLocal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvDelete() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_KvDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDelete(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvDelete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvBatchPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvBatchPut() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_KvBatchPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchPut(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchPutRequest* /*request*/, ::phxkv::KvBatchPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvBatchPut(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvBatchGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvBatchGet() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_KvBatchGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchGet(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchGetRequest* /*request*/, ::phxkv::KvBatchGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvBatchGet(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvGetgroupList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvGetgroupList() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_KvGetgroupList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetgroupList(::grpc::ServerContext* /*context*/, const ::phxkv::GroupListReq* /*request*/, ::phxkv::GroupListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvGetgroupList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvDropMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvDropMaster() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_KvDropMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDropMaster(::grpc::ServerContext* /*context*/, const ::phxkv::DropMastReq* /*request*/, ::phxkv::DropMastRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvDropMaster(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KvBeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KvBeMaster() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_KvBeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBeMaster(::grpc::ServerContext* /*context*/, const ::phxkv::BemasterReq* /*request*/, ::phxkv::BemasterRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKvBeMaster(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HashOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HashOperate() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_HashOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashOperate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListOperate() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ListOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListOperate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetOperate() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_SetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetOperate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ZsetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ZsetOperate() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ZsetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZsetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestZsetOperate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvPut() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvPut(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvPut(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvPut(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvPut(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvGet() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvGet(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvGet(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvGet(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvGetLocal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvGetLocal() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvGetLocal(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvGetLocal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetLocal(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvGetLocal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvGetLocal(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvDelete() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvDelete(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDelete(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvDelete(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvDelete(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvBatchPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvBatchPut() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvBatchPut(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvBatchPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchPut(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchPutRequest* /*request*/, ::phxkv::KvBatchPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvBatchPut(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvBatchPut(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvBatchGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvBatchGet() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvBatchGet(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvBatchGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBatchGet(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchGetRequest* /*request*/, ::phxkv::KvBatchGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvBatchGet(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvBatchGet(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvGetgroupList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvGetgroupList() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvGetgroupList(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvGetgroupList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvGetgroupList(::grpc::ServerContext* /*context*/, const ::phxkv::GroupListReq* /*request*/, ::phxkv::GroupListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvGetgroupList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvGetgroupList(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvDropMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvDropMaster() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvDropMaster(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvDropMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvDropMaster(::grpc::ServerContext* /*context*/, const ::phxkv::DropMastReq* /*request*/, ::phxkv::DropMastRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvDropMaster(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvDropMaster(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KvBeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KvBeMaster() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KvBeMaster(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KvBeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KvBeMaster(::grpc::ServerContext* /*context*/, const ::phxkv::BemasterReq* /*request*/, ::phxkv::BemasterRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KvBeMaster(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KvBeMaster(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HashOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_HashOperate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HashOperate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_HashOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HashOperate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HashOperate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListOperate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListOperate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListOperate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListOperate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetOperate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetOperate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetOperate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetOperate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ZsetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ZsetOperate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ZsetOperate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ZsetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZsetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ZsetOperate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ZsetOperate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvPut() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::KVOperator, ::phxkv::KVResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::KVOperator, ::phxkv::KVResponse>* streamer) {
                       return this->StreamedKvPut(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvPut(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvPut(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::KVOperator,::phxkv::KVResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvGet() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::KVOperator, ::phxkv::KVResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::KVOperator, ::phxkv::KVResponse>* streamer) {
                       return this->StreamedKvGet(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvGet(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::KVOperator,::phxkv::KVResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvGetLocal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvGetLocal() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::KVOperator, ::phxkv::KVResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::KVOperator, ::phxkv::KVResponse>* streamer) {
                       return this->StreamedKvGetLocal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvGetLocal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvGetLocal(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvGetLocal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::KVOperator,::phxkv::KVResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvDelete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvDelete() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::KVOperator, ::phxkv::KVResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::KVOperator, ::phxkv::KVResponse>* streamer) {
                       return this->StreamedKvDelete(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvDelete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvDelete(::grpc::ServerContext* /*context*/, const ::phxkv::KVOperator* /*request*/, ::phxkv::KVResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvDelete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::KVOperator,::phxkv::KVResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvBatchPut : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvBatchPut() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::KvBatchPutRequest, ::phxkv::KvBatchPutResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::KvBatchPutRequest, ::phxkv::KvBatchPutResponse>* streamer) {
                       return this->StreamedKvBatchPut(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvBatchPut() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvBatchPut(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchPutRequest* /*request*/, ::phxkv::KvBatchPutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvBatchPut(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::KvBatchPutRequest,::phxkv::KvBatchPutResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvBatchGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvBatchGet() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::KvBatchGetRequest, ::phxkv::KvBatchGetResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::KvBatchGetRequest, ::phxkv::KvBatchGetResponse>* streamer) {
                       return this->StreamedKvBatchGet(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvBatchGet() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvBatchGet(::grpc::ServerContext* /*context*/, const ::phxkv::KvBatchGetRequest* /*request*/, ::phxkv::KvBatchGetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvBatchGet(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::KvBatchGetRequest,::phxkv::KvBatchGetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvGetgroupList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvGetgroupList() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::GroupListReq, ::phxkv::GroupListRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::GroupListReq, ::phxkv::GroupListRes>* streamer) {
                       return this->StreamedKvGetgroupList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvGetgroupList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvGetgroupList(::grpc::ServerContext* /*context*/, const ::phxkv::GroupListReq* /*request*/, ::phxkv::GroupListRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvGetgroupList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::GroupListReq,::phxkv::GroupListRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvDropMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvDropMaster() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::DropMastReq, ::phxkv::DropMastRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::DropMastReq, ::phxkv::DropMastRes>* streamer) {
                       return this->StreamedKvDropMaster(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvDropMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvDropMaster(::grpc::ServerContext* /*context*/, const ::phxkv::DropMastReq* /*request*/, ::phxkv::DropMastRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvDropMaster(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::DropMastReq,::phxkv::DropMastRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KvBeMaster : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KvBeMaster() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::BemasterReq, ::phxkv::BemasterRes>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::BemasterReq, ::phxkv::BemasterRes>* streamer) {
                       return this->StreamedKvBeMaster(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KvBeMaster() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KvBeMaster(::grpc::ServerContext* /*context*/, const ::phxkv::BemasterReq* /*request*/, ::phxkv::BemasterRes* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKvBeMaster(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::BemasterReq,::phxkv::BemasterRes>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HashOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HashOperate() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::Request, ::phxkv::Response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::Request, ::phxkv::Response>* streamer) {
                       return this->StreamedHashOperate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HashOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HashOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHashOperate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::Request,::phxkv::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListOperate() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::Request, ::phxkv::Response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::Request, ::phxkv::Response>* streamer) {
                       return this->StreamedListOperate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListOperate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::Request,::phxkv::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetOperate() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::Request, ::phxkv::Response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::Request, ::phxkv::Response>* streamer) {
                       return this->StreamedSetOperate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetOperate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::Request,::phxkv::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ZsetOperate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ZsetOperate() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::phxkv::Request, ::phxkv::Response>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::phxkv::Request, ::phxkv::Response>* streamer) {
                       return this->StreamedZsetOperate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ZsetOperate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ZsetOperate(::grpc::ServerContext* /*context*/, const ::phxkv::Request* /*request*/, ::phxkv::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedZsetOperate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::phxkv::Request,::phxkv::Response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_KvPut<WithStreamedUnaryMethod_KvGet<WithStreamedUnaryMethod_KvGetLocal<WithStreamedUnaryMethod_KvDelete<WithStreamedUnaryMethod_KvBatchPut<WithStreamedUnaryMethod_KvBatchGet<WithStreamedUnaryMethod_KvGetgroupList<WithStreamedUnaryMethod_KvDropMaster<WithStreamedUnaryMethod_KvBeMaster<WithStreamedUnaryMethod_HashOperate<WithStreamedUnaryMethod_ListOperate<WithStreamedUnaryMethod_SetOperate<WithStreamedUnaryMethod_ZsetOperate<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_KvPut<WithStreamedUnaryMethod_KvGet<WithStreamedUnaryMethod_KvGetLocal<WithStreamedUnaryMethod_KvDelete<WithStreamedUnaryMethod_KvBatchPut<WithStreamedUnaryMethod_KvBatchGet<WithStreamedUnaryMethod_KvGetgroupList<WithStreamedUnaryMethod_KvDropMaster<WithStreamedUnaryMethod_KvBeMaster<WithStreamedUnaryMethod_HashOperate<WithStreamedUnaryMethod_ListOperate<WithStreamedUnaryMethod_SetOperate<WithStreamedUnaryMethod_ZsetOperate<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace phxkv


#endif  // GRPC_phxkv_2eproto__INCLUDED
